#APP研发录第三章笔记
---
第一小节请看我的博客：

[《APP研发录》之App图片缓存设计](http://blog.csdn.net/CodeEmperor/article/details/50478384)

###3.2 对网络流量进行优化

慢点儿没关系，尤其是2G网络。但是动不动就弹出“无法连接到网络”或者“网络连接超时”的对话框，就是我们开发人员必须要解决的问题了。

####3.2.1 通信层面的优化

先从MobileAPI层面进行优化：

1. MobileAPI接口返回的数据，要使用gzip进行压缩。注意：大于1KB才进行压缩，否则得不偿失。经过gzip压缩后，返回的数据量大幅减少。
2. App与MobileAPI之间的数据传递，通常是遵守JSON协议的。JSON因为是xml格式的，并且是以字符存在的，在数据量上还有可以压缩的空间。我这里推荐一种新的数据传输协议，那就是ProtoBuffer。这种协议是二进制格式的，所以在表示大数据时，空间比JSON小很多。
3. 解决频繁调用MobileAPI的问题。网络请求，服务器处理的速度是很快的，主要花费的时间在数据传输上，移动开发人员需要关注的是，减少网络访问次数，能调用一次MobileAPI接口就能取到数据的，就不要调用两次。
4. 我们知道，传统的MobileAPI使用的是HTTP无状态短连接。使用HTTP协议的速度远不如使用TCP协议，因为后者是长连接。所以我们可以使用TCP长连接，以提高访问的速度。缺点是一台服务器能支持的长连接个数不多，所以需要更多的服务器集成。
5. 要建立取消网络请求的机制。一个页面如果没有请求完网络数据，在跳转到另一个页面之前，要把之前的网络请求都取消，不再等待，也不再接收数据。无论是iOS还是Android，都应该在基类（BaseViewController或者BaseActivity）中提供一个cancelRequest的方法，用以在离开当前页面时清空网络请求队列。
6. 增加重试机制。如果MobileAPI是严格的RESTful风格，那么我们一般将获取数据的请求接口都定义为get；而把操作数据的请求接口都定义为post。

####3.2.2 图片策略优化

**1.要确保下载的每张图，都符合ImageView控件的大小**

**2.低流量模式**

在2G和3G网络环境下，我们应该适当降低图片的质量。降低图片质量，相应的图片大小也会降低，我们称为低流量模式。

**3.极速模式**

在2G和3G网络环境下，用户大多对图片不感兴趣，他们可能就是想快速下单并支付，我们需要额外设计一些页面，区别于正常模式下图文并茂的页面，我们将这些只有文字的页面称为极速模式。

在每次开启App进入首页前会先进行预判，如果发现当前网络环境为2G、3G或4G，但是当前模式为正常模式，就会弹出一个对话框询问用户，是否要进入极速模式以节省流量。如果是WiFi网络环境，但当前模式是极速模式，也会提示用户是否要切换回正常模式，以看到最炫的效果。

###3.3 城市列表的设计

####城市列表数据

一份城市列表的数据包括以下几个字典：

* cityId:城市id
* cityName:城市名称
* pinyin:城市全拼
* jianpin:城市简拼

其中，全拼和简拼是用来在App本地做字母表排序和关键字检索的。
我曾经经历过把城市列表数据写死在本地文件的做法，日积月累，就会产生两个问题：

* Android和iOS维护的数据，差异会越来越大。
* 一千多个城市，每次从本地加载都要很长时间。

针对问题1的解决办法是，写一个文本分析工具，找出Android和iOS各自维护文件的不同数据。

把城市列表数据保存在本地，有个很烦的事情，就是每次增加新的城市，都要等下次发版，因为数据是写死在App本地的。于是，我们把城市列表数据做成一个MobileAPI接口，由MobileAPI去后台采集数据，这样数据是最新最准的。

但是这样做的问题是，这个MobileAPI接口返回的数据量会很大，上千笔数据，还包括那么多字段，即使打开了gzip压缩，也会有100k的样子。于是我们又增加了版本号字段version的概念，这个MobileAPI接口的定义和返回的JSON格式是这样的：

1. 入参。version，本地存储的城市列表数据对应的版本号。
2. 返回值。如果传入参数version和线上最新版本号一致，则返回以下固定格式：

```
{
  "isMatch": false,
    "version": 1,
      "cities": [
        {
        },
      ]
} 
```

如果传入参数version和线上最新版本号不一致，则返回以下格式：

```
{
    "isMatch": false,
    "version": 1,
    "cities": [
        {
            "cityId": 1,
            "cityName": "北京",
            "pinyin": "beijing",
            "jianpin": "bj"
        },
        {
            "cityId": 2,
            "cityName": "上海",
            "pinyin": "shanghai",
            "jianpin": "sh"
        },
        {
            "cityId": 3,
            "cityName": "平顶山",
            "pinyin": "pingdingshan",
            "jianpin": "pds"
        }
    ]
} 
```

version这个字段由MobileAPI进行更新，每当有城市数据更新时，version可以立即自增+1，也可以积累到一定数据后自增+1。具体策略由MobileAPI来决定。

基于此，App的策略可以是这样的：

1. 本地仍然保存一份线上最新的城市列表数据（序列化后的）以及对应的版本号。我们要求每次发版前做一次城市数据同步的事情。
2. 每次进入到城市列表这个页面时，将本地城市列表数据对应的版本号version传入到MobileAPI接口，根据返回的isMatch值来决定是否版本号一致。如果一致，则直接从本地文件中加载城市列表数据；否则，就解析MobileAPI接口返回的数据，在显示列表的同时，记得要把最新的城市列表数据和版本号保存到本地。
3. 如果MobileAPI接口没有调用成功，也是直接从本地文件中加载城市列表数据，以确保主流程是畅通的。
4. 每次调用MobileAPI时，会获取到大量的数据，一般我们会打开gzip对数据进行压缩，以确保传输的数据量最小。

####3.3.2　城市列表数据的增量更新机制

###3.4







